/*
 * Copyright 2019 The Kythe Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.devtools.kythe.analyzers.java;

import com.google.auto.service.AutoService;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.devtools.kythe.analyzers.base.EdgeKind;
import com.google.devtools.kythe.analyzers.base.EntrySet;
import com.google.devtools.kythe.analyzers.java.Plugin.KytheNode;
import com.google.devtools.kythe.proto.Storage.VName;
import com.sun.tools.javac.api.JavacTrees;
import com.sun.tools.javac.code.Symtab;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.code.Type.ClassType;
import com.sun.tools.javac.code.Type.MethodType;
import com.sun.tools.javac.code.Types;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.JCAnnotation;
import com.sun.tools.javac.tree.JCTree.JCAssign;
import com.sun.tools.javac.tree.JCTree.JCClassDecl;
import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
import com.sun.tools.javac.tree.JCTree.JCExpression;
import com.sun.tools.javac.tree.JCTree.JCLiteral;
import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
import com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;
import com.sun.tools.javac.util.Context;
import com.sun.tools.javac.util.Names;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.TypeKind;

@AutoService(Plugin.class)
/** Kythe {@link Plugin} that emits property entries for {@link AutoValue} classes. */
public class AutoValuePlugin extends Plugin.Scanner<Void, Void> {
  private static final ImmutableSet<String> GENERATED_ANNOTATIONS =
      ImmutableSet.of("javax.annotation.Generated", "javax.annotation.processing.Generated");

  private static final String AUTO_VALUE_PKG = "com.google.auto.value";
  private static final String AUTO_VALUE_ANNOTATION = AUTO_VALUE_PKG + ".AutoValue";
  private static final String BUILDER_ANNOTATION = AUTO_VALUE_ANNOTATION + ".Builder";
  private static final String AUTO_VALUE_PROCESSOR =
      AUTO_VALUE_PKG + ".processor.AutoValueProcessor";

  private JavacTrees javacTrees;
  private Types types;

  public AutoValuePlugin() {}

  @Override
  public Void visitTopLevel(JCCompilationUnit compilation, Void v) {
    Context context = kytheGraph.getJavaContext();
    Symtab symtab = Symtab.instance(context);
    Names names = Names.instance(context);
    if (Iterables.isEmpty(symtab.getClassesForName(names.fromString(AUTO_VALUE_ANNOTATION)))) {
      // No AutoValue class detected in compilation; early exit.
      return null;
    }
    javacTrees = JavacTrees.instance(context);
    types = Types.instance(context);
    return super.visitTopLevel(compilation, v);
  }

  @Override
  public Void visitClassDef(JCClassDecl classDef, Void v) {
    return handleAutoValue(classDef) ? null : super.visitClassDef(classDef, v);
  }

  private boolean handleAutoValue(JCClassDecl classDef) {
    // Check if class was generated by the AutoValueProcessor
    if (!classDef.getModifiers().getAnnotations().stream()
        .filter(
            // Class decorated by @Generated(value = "...AutoValueProcessor")
            ann ->
                GENERATED_ANNOTATIONS.contains(annotationName(ann))
                    && AUTO_VALUE_PROCESSOR.equals(annotationLiteralValue(ann, "value")))
        .findFirst()
        .isPresent()) {
      return false;
    }

    // Find @AutoValue superclass definition.
    JCClassDecl autoValueClass = null;
    ClassType classType = (ClassType) classDef.type;
    while (autoValueClass == null && classType.supertype_field instanceof ClassType) {
      classType = (ClassType) classType.supertype_field;
      JCTree superTypeTree = javacTrees.getTree(classType.asElement());
      if (superTypeTree instanceof JCClassDecl) {
        JCClassDecl cls = (JCClassDecl) superTypeTree;
        if (getAnnotation(AUTO_VALUE_ANNOTATION, cls.getModifiers().getAnnotations()).isPresent()) {
          autoValueClass = cls;
        }
      }
    }
    if (autoValueClass == null) {
      return false;
    }

    // @AutoValue class generates the implementation class.
    Optional<KytheNode> autoNode = kytheGraph.getNode(autoValueClass.sym);
    Optional<KytheNode> genNode = kytheGraph.getNode(classDef.sym);
    if (autoNode.isPresent() && genNode.isPresent()) {
      entrySets.emitEdge(autoNode.get().getVName(), EdgeKind.GENERATES, genNode.get().getVName());
    }

    Map<String, JCMethodDecl> propMethods = new HashMap<>(); // property_name -> getter method
    Map<String, VName> getterNodes = new HashMap<>(); // property_name -> Kythe getter VName
    Map<String, VName> properties = new HashMap<>(); // property_name -> Kythe property node VName

    // Find potential propMethods in @AutoValue class.
    for (JCTree def : autoValueClass.getMembers()) {
      if (def instanceof JCMethodDecl) {
        JCMethodDecl method = (JCMethodDecl) def;
        if (method.getModifiers().getFlags().contains(Modifier.ABSTRACT)
            && method.getParameters().isEmpty()
            && !isVoid(method.getReturnType())) {
          Optional<KytheNode> kytheNode = kytheGraph.getNode(method.sym);
          if (kytheNode.isPresent()) {
            String name = method.sym.getSimpleName().toString();
            // TODO(schroederc): possibly reuse getter method as "property" node or change node kind
            EntrySet propNode =
                entrySets.newNode("property").addSignatureSalt(kytheNode.get().getVName()).build();
            propNode.emit(entrySets.getEmitter());
            entrySets.emitEdge(
                kytheNode.get().getVName(), EdgeKind.PROPERTY_READS, propNode.getVName());

            properties.put(name, propNode.getVName());
            propMethods.put(name, method);
            getterNodes.put(name, kytheNode.get().getVName());
          }
        }
      }
    }
    if (propMethods.isEmpty()) {
      return false;
    }

    // Either all getters must be prefixed or all names are taken as written.
    boolean allPrefixed =
        properties.keySet().stream().allMatch(AutoValuePlugin::hasGetPropertyPrefix);
    if (allPrefixed) {
      Map<String, VName> additional = new HashMap<>();
      for (Map.Entry<String, VName> prop : properties.entrySet()) {
        additional.put(propertyName(prop.getKey()), prop.getValue());
      }
      properties.putAll(additional);
    }

    // Find potential @AutoValue.Builder and its defined setters.
    Optional<KytheNode> builderNode = Optional.empty();
    JCClassDecl builderClass = null;
    Map<String, VName> setterNodes = new HashMap<>(); // property_name -> Kythe setter VName
    for (JCTree def : autoValueClass.getMembers()) {
      if (def instanceof JCClassDecl) {
        JCClassDecl subClass = (JCClassDecl) def;
        if (getAnnotation(BUILDER_ANNOTATION, subClass.getModifiers().getAnnotations())
            .isPresent()) {
          builderClass = subClass;
          builderNode = kytheGraph.getNode(builderClass.sym);
          for (JCTree builderDef : builderClass.getMembers()) {
            if (builderDef instanceof JCMethodDecl) {
              JCMethodDecl method = (JCMethodDecl) builderDef;
              Type retType = ((MethodType) method.type).restype;
              if (method.getModifiers().getFlags().contains(Modifier.ABSTRACT)
                  && method.getParameters().size() == 1
                  && builderClass.type.equals(retType)) {
                Optional<KytheNode> kytheNode = kytheGraph.getNode(method.sym);
                if (kytheNode.isPresent()) {
                  String name = method.sym.getSimpleName().toString();
                  VName propNode =
                      properties.containsKey(name)
                          ? properties.get(name)
                          : properties.get(propertyName(name));
                  if (propNode != null) {
                    entrySets.emitEdge(
                        kytheNode.get().getVName(), EdgeKind.PROPERTY_WRITES, propNode);
                    setterNodes.put(name, kytheNode.get().getVName());
                  }
                }
              }
            }
          }
          break;
        }
      }
    }

    // For each generated member, mark as reader of corresponding property.
    for (JCTree def : classDef.getMembers()) {
      if (def instanceof JCMethodDecl) {
        JCMethodDecl method = (JCMethodDecl) def;
        String name = method.sym.getSimpleName().toString();
        if (method.getParameters().isEmpty() && propMethods.containsKey(name)) {
          Optional<KytheNode> kytheNode = kytheGraph.getNode(method.sym);
          if (kytheNode.isPresent()) {
            VName propNode = properties.get(name);
            entrySets.emitEdge(kytheNode.get().getVName(), EdgeKind.PROPERTY_READS, propNode);
            entrySets.emitEdge(
                getterNodes.get(name), EdgeKind.GENERATES, kytheNode.get().getVName());
          }
        }
      } else if (def instanceof JCClassDecl) {
        JCClassDecl subClass = (JCClassDecl) def;
        if (builderClass != null && types.isSuperType(builderClass.type, subClass.type)) {
          JCClassDecl genBuilder = subClass;
          Optional<KytheNode> builderGenNode = kytheGraph.getNode(genBuilder.sym);
          if (builderGenNode.isPresent() && builderNode.isPresent()) {
            entrySets.emitEdge(
                builderNode.get().getVName(), EdgeKind.GENERATES, builderGenNode.get().getVName());
          }
          for (JCTree builderDef : genBuilder.getMembers()) {
            if (builderDef instanceof JCMethodDecl) {
              JCMethodDecl method = (JCMethodDecl) builderDef;
              Type retType = ((MethodType) method.type).restype;
              if (method.getParameters().size() == 1 && builderClass.type.equals(retType)) {
                Optional<KytheNode> kytheNode = kytheGraph.getNode(method.sym);
                if (kytheNode.isPresent()) {
                  String name = method.sym.getSimpleName().toString();
                  VName propNode =
                      properties.containsKey(name)
                          ? properties.get(name)
                          : properties.get(propertyName(name));
                  if (propNode != null) {
                    entrySets.emitEdge(
                        kytheNode.get().getVName(), EdgeKind.PROPERTY_WRITES, propNode);
                    entrySets.emitEdge(
                        setterNodes.get(name), EdgeKind.GENERATES, kytheNode.get().getVName());
                  }
                }
              }
            }
          }
        }
      }
    }
    return true;
  }

  private static Optional<JCAnnotation> getAnnotation(String name, List<JCAnnotation> annotations) {
    return annotations.stream().filter(ann -> annotationName(ann).equals(name)).findFirst();
  }

  private static String annotationName(JCAnnotation ann) {
    return ann.getAnnotationType().type.tsym.toString();
  }

  private static Object annotationLiteralValue(JCAnnotation ann, String name) {
    for (JCExpression expr : ann.getArguments()) {
      JCAssign a = (JCAssign) expr;
      if (a.lhs.toString().equals(name) && a.rhs instanceof JCLiteral) {
        return ((JCLiteral) a.rhs).value;
      }
    }
    return null;
  }

  private static boolean hasGetPropertyPrefix(String name) {
    return name.startsWith("get") || name.startsWith("is");
  }

  private static String propertyName(String name) {
    if (name.startsWith("get") || name.startsWith("set")) {
      name = name.substring(3);
    } else if (name.startsWith("is")) {
      name = name.substring(2);
    }
    return name.isEmpty()
            || (name.length() >= 2
                && Character.isUpperCase(name.charAt(0))
                && Character.isUpperCase(name.charAt(1)))
        ? name
        : Character.toLowerCase(name.charAt(0)) + name.substring(1);
  }

  private static boolean isVoid(JCTree tree) {
    return tree instanceof JCPrimitiveTypeTree
        && TypeKind.VOID.equals(((JCPrimitiveTypeTree) tree).getPrimitiveTypeKind());
  }
}
